<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Neil Ding]]></title>
  <link href="http://gxding.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://gxding.com/"/>
  <updated>2016-04-04T10:21:37-04:00</updated>
  <id>http://gxding.com/</id>
  <author>
    <name><![CDATA[Neil Ding]]></name>
    <email><![CDATA[bbbear444@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[first expose to test]]></title>
    <link href="http://gxding.com/blog/2015/04/26/first-expose-to-test/"/>
    <updated>2015-04-26T16:50:00-04:00</updated>
    <id>http://gxding.com/blog/2015/04/26/first-expose-to-test</id>
    <content type="html"><![CDATA[<p>I have seen quite a lot of talking about test, and tried a little RSpec when learning Ruby on Rails years ago. But I don&rsquo;t really get myself dig into the testing world. Today is Sunday, it&rsquo;s a sudden that come to my mind that maybe I should spend some time figure it out.</p>

<p>It&rsquo;s a sad fact that the company I am working never encourage writing test for project. It relays a lot on human QA. Well that&rsquo;s not bad in some sense. But apparently we can be more efficient and get less bug if we adopt automated test. There seems to be architecture change in term of development. I found it a good chance to add test to the new architecture.</p>

<p>I just spend an afternoon make the test working for the <a href="https://github.com/GingerBear/nba-daily">nba-daily project</a> that I have worked months ago. It has similar idea behind the company project, which proxying site to a better UI. In the mind, the test should be to pretty simple, namely, going to a page, checking that page contains what we need, going to another page, checking again.</p>

<p>Check element is pretty common in testing. Most test framework and assert library should already taken then cared. The only thing is to requesting page. Obviously we cannot use node&rsquo;s plane http request module because if the real project, the request has to maintain the cookie and session. Normally cookie and session is handled by browser, so my first head to find those browser testing tools. It turns out that there is thing called Selenium, which can opens up local or remote browser, and use the browser to make the request. It can use different web driver to drive different browser. I tried the <code>chai-webdriver</code> and chrome driver, it works, but it won&rsquo;t work on the Travis CI, which doesn&rsquo;t have a browser GUI. To make Travis work, we need to use remote browser on virtual machine. I know that I have pay to use that.</p>

<p>Then it come up another solution, PhantomJS. It call itself <code>headless WebKit</code>. It&rsquo;s hard to understand what is headless. But to my understanding, it&rsquo;s browser without GUI, and can be fully controlled by JavaScript (comparing to real browsers that expose limited API). And fortunately, Travis CI have PhantomJS pre installed on their virtual machine. So to make the whole thing work, I just need to plugin phantomjs into my test.</p>

<p>At the beginning, it&rsquo;s confused me when I found phantomjs is not coded with JavaScript (but C++), nor it&rsquo;s a node module. I was mistakenly thought that it&rsquo;s node implementation of browser, it can be npm installed. It turns out that it doesn&rsquo;t have much to do with nodejs. They are completely two different environment. I was trying to try the simple code on the doc, but it just not works.</p>

<p>After digging a while, I found that to make phantomjs working in node, I need to instal a bridge to make communicate, which is node module. With the bridge, I can create a phantomjs instance, then create a page instance, then open a url. After I get the response, I evaluate a piece of JavaScript function to get what we want on the page. I just typing something in the browser console and expecting something coming bac. Another interesting thing is, we I run the test, I can see the server response in my node terminal, which also include those assets request. This also proved that phantomjs is a <code>real</code> browser. At this point, I get everything I need.</p>

<p>I pick up the most used (or most famous) test tool, mocha and chai to construct the test case. Soon I found that the assert need to be async. It need to assert after the request is done. Mocha provide a very nice way to achieve, simply call the done() function after asynchronously  assert. A very nice thing about phantomjs here is that, one of my request is based on the ajax call on the page. As long as I set a few seconds timeout to wait for the request is done, test is totally working!</p>

<p>When I try to intentionally fail the test, gotcha occur. When I fail the first test, the rest tests all get timeouted error. It wired, since if one failed, the test should show that they should show, either success or fail, why it&rsquo;s a timeout error? It turns out that, when a async test failed, the assert will throw an error. So the following done() function will never run, which make the rest tests timeout. The solution is to wrap a try catch to assert and done, and call done again in the catch with e as params. So when assert failed, done will still get called.</p>

<p>After all test working locally, the deployment just work out of the box. Travis will automatically run <code>npm test</code> if there is one in the package.json. So I send a pr, all build and test start running automatically. After a while, pass all green. yay!</p>

<p><img src="/images/travis-pass.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A wandering on CSS3]]></title>
    <link href="http://gxding.com/blog/2014/02/17/a-wandering-on-css3/"/>
    <updated>2014-02-17T13:19:00-05:00</updated>
    <id>http://gxding.com/blog/2014/02/17/a-wandering-on-css3</id>
    <content type="html"><![CDATA[<p>CSS3 sounds like new tech, but it has been around for years with a increasing adoption on main browsers. I have been using CSS for years, but mostly using those main features, or triditional CSS2 features like position, styling, flaoting, etc, and a little bit decorating CSS3 features like border-radius, and box-shadow. CSS is not difficult, and when I think I have master the basic, I stop exploring those new features and believe that they are still on the way on browser compatbility.</p>

<p>Recently front end technique is envolving so fast that experimental CSS3 things now become practical. Also due to the face that I have preparing for the front end job interview, I am going to make a wandering on these new features of CSS3.</p>

<h3>Decoration</h3>

<h4>box-shadow, border-radius, opacity</h4>

<p>Most common used CSS3 features, and they are very well supported by modern browsers. <code>box-shadow</code> make shadow very easy in web pages. There are several paramaters to precisely control shadows, color, offset, blur, speard and inner/outter. It is often use in popup, dropdown. It is already been vendor-prefix freed on my just look on google plus sharing popup. <code>border-radius</code> is a interesting one. It used to be a lot of round coner hack out there. Like background image replacing, pixel mimicing. And I used to get excieted by there hacks. But now, they all gone by the missive adoption of <code>border-radius</code>. It sample to use. We can control four corner by four radius parameters. <code>opacity</code> is intiative that it control the trnasperency of a element with a percentage value, which is very useful in styling, and has no side effect.</p>

<h3>Flexbox and layout</h3>

<p>I heard <code>flexbox</code> very early, with the phrase that it is the most wanted feature in CSS3. From my recent learning, it is used for layout, which is one of the most discuessed topic in css layout. There used to be 3 main layout methods on the market. Table is the note ancient. It put elements into a big table, arrange them by tr, td. It is sample but it not flexible. If we want complex layout, the markup will be massed. Second is using float. It is massively adopted. Elements is arranged horizontally by fix the width and float them. The limitation is that Their width are fixed, or at least one of them is fixed. Besides, it need some tricky way to clear these float. Third is using absolut position to control layout. The advantage is that they are very easy to control. It is more like drawing, rather than arranging. The drawback is that the main flow is breaked. The normal element flow is breaked, which make the layout less extendable.</p>

<p>Here comes the flexbox, it natually arrange the element horizontally in the flex contianer, or vertically. In the flex box container, it is very configrable to layout elements, not matter by horizontal, vertical, alignment, centering, evenly seperated, growing differently, or by custom order. It is like a new box flowing model that completely independent on normal box flow. So the flow item will not be affected by <code>float</code>, <code>clean</code> and <code>vertical-align</code>.</p>

<p>Another things need to be mentioned about layout is Grid system. Grid system is not a native css feature, but a third-party position framework that arrange elements on the page, by specifing a pre-defined class. It is suggested a optimal solution for large scaled page layout. From my personal usage of Bootstrap grid system, I feel it less flexible, but more consistent cross multi-pages. Also by grid system it is easy to implement an integrated responsive solutions.</p>

<h3>Animation</h3>

<h4>transition, animation</h4>

<p>Animation is good feature to make some easy animation. It is fairly sample to use and, more importantly, rendered by GPU, which means more smooth animation. There are two type of animation, transition and animation. Transition is simpler. It is a property of one element that indication some change of property should be gradually made. For example, element&rsquo;s width is changed by hovering. The width will change gradually. Change can only be applied to a set of properties like height/width, opacity, color, padding, margin, border, left/top. Properties that could be changed gradually. These change may triggered by a lot of event, hover, click, media-query, and javascript add class. Some parameter can also be added, like duration, delay, ease/linear, infinite.</p>

<p>Animation is little different. In order to make a animation. We first need to define an keyframe, which is defined by a bunch of properties in a period property. from <code>from</code> to <code>to</code>, or from <code>0%</code> to <code>50%</code> to <code>100%</code>. With keyframe defined, it can be assign to element by animation property, with a bunch of parameters like delay, duration, ease/linear, alternate, infinite to indicate that animation.</p>

<p>Another property is necessary to mention here, which is transform. I used to confuse it with transition. May because they looks like or they are always used together. So transform is just about four things: translate, scale, rotate, skew, and something matrix or 3d stuff. It can change an element&rsquo;s position, scale it, rotate it, and skew it.</p>

<p>TranslateZ(0) could be use as a hack to improve page render performance. It force an element into a new layer, to avoid unnecessary re-paint.</p>

<h3>Media Query</h3>

<p>Media Query is use to deal with different style for differnt devices or different screen size. With a media query, we can define a specific style for screen or print with max/min with of screen, orientation of device, use logic operator like and/or. When critiria meet, browser will load styles in it. This feature make reponsive design happened.</p>

<h3>Pseudo things</h3>

<p>Pseudo things include Pseudo class and Pseudo elements. Pseudo classes refers to most used hover, active, checked, focus. Some newly adoped CSS3 seletor like nth-child(), first-child, root. Pseudo element is more used, which is :before and :after. They literally insert a same element before/after the target element. We could set style on them to add no-sematic content-based style, like quotes, icon. They can also be used to clearfix float, by a after pseudo-element. Pseedo element must have a content property. Its content can be fill dymanically with markup attributes by <code>attr()</code>. There are a lot of interesting pseudo element usage in <a href="http://css-tricks.com/pseudo-element-roundup/">this page</a>.</p>

<ul>
<li>END &ndash;</li>
</ul>

]]></content>
  </entry>
  
</feed>
